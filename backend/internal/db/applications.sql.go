// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: applications.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteApplication = `-- name: DeleteApplication :exec
DELETE FROM applications
WHERE id = $1
`

func (q *Queries) DeleteApplication(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteApplication, id)
	return err
}

const getApplicationByID = `-- name: GetApplicationByID :one
SELECT id, user_id, company_name, job_title, job_url, applied_at, status, email_thread_id, notes, tags, resume_version, status_history, created_at, updated_at FROM applications
WHERE id = $1
`

func (q *Queries) GetApplicationByID(ctx context.Context, id pgtype.UUID) (Application, error) {
	row := q.db.QueryRow(ctx, getApplicationByID, id)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyName,
		&i.JobTitle,
		&i.JobUrl,
		&i.AppliedAt,
		&i.Status,
		&i.EmailThreadID,
		&i.Notes,
		&i.Tags,
		&i.ResumeVersion,
		&i.StatusHistory,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getApplicationsByUser = `-- name: GetApplicationsByUser :many
SELECT id, user_id, company_name, job_title, job_url, applied_at, status, email_thread_id, notes, tags, resume_version, status_history, created_at, updated_at FROM applications
WHERE user_id = $1
ORDER BY applied_at DESC
`

func (q *Queries) GetApplicationsByUser(ctx context.Context, userID pgtype.UUID) ([]Application, error) {
	rows, err := q.db.Query(ctx, getApplicationsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CompanyName,
			&i.JobTitle,
			&i.JobUrl,
			&i.AppliedAt,
			&i.Status,
			&i.EmailThreadID,
			&i.Notes,
			&i.Tags,
			&i.ResumeVersion,
			&i.StatusHistory,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertApplication = `-- name: InsertApplication :one
INSERT INTO applications (
  user_id, company_name, job_title, job_url,
  applied_at, status, email_thread_id,
  notes, tags, resume_version, status_history
)
VALUES (
  $1, $2, $3, $4,
  $5, $6, $7,
  $8, $9, $10, $11
)
RETURNING id, user_id, company_name, job_title, job_url, applied_at, status, email_thread_id, notes, tags, resume_version, status_history, created_at, updated_at
`

type InsertApplicationParams struct {
	UserID        pgtype.UUID        `json:"user_id"`
	CompanyName   string             `json:"company_name"`
	JobTitle      string             `json:"job_title"`
	JobUrl        pgtype.Text        `json:"job_url"`
	AppliedAt     pgtype.Timestamptz `json:"applied_at"`
	Status        string             `json:"status"`
	EmailThreadID pgtype.Text        `json:"email_thread_id"`
	Notes         pgtype.Text        `json:"notes"`
	Tags          []string           `json:"tags"`
	ResumeVersion pgtype.Text        `json:"resume_version"`
	StatusHistory []byte             `json:"status_history"`
}

func (q *Queries) InsertApplication(ctx context.Context, arg InsertApplicationParams) (Application, error) {
	row := q.db.QueryRow(ctx, insertApplication,
		arg.UserID,
		arg.CompanyName,
		arg.JobTitle,
		arg.JobUrl,
		arg.AppliedAt,
		arg.Status,
		arg.EmailThreadID,
		arg.Notes,
		arg.Tags,
		arg.ResumeVersion,
		arg.StatusHistory,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyName,
		&i.JobTitle,
		&i.JobUrl,
		&i.AppliedAt,
		&i.Status,
		&i.EmailThreadID,
		&i.Notes,
		&i.Tags,
		&i.ResumeVersion,
		&i.StatusHistory,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateApplicationStatus = `-- name: UpdateApplicationStatus :exec
UPDATE applications
SET status = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateApplicationStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateApplicationStatus(ctx context.Context, arg UpdateApplicationStatusParams) error {
	_, err := q.db.Exec(ctx, updateApplicationStatus, arg.ID, arg.Status)
	return err
}

const updateApplicationThreadID = `-- name: UpdateApplicationThreadID :exec
UPDATE applications
SET email_thread_id = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateApplicationThreadIDParams struct {
	ID            pgtype.UUID `json:"id"`
	EmailThreadID pgtype.Text `json:"email_thread_id"`
}

func (q *Queries) UpdateApplicationThreadID(ctx context.Context, arg UpdateApplicationThreadIDParams) error {
	_, err := q.db.Exec(ctx, updateApplicationThreadID, arg.ID, arg.EmailThreadID)
	return err
}
